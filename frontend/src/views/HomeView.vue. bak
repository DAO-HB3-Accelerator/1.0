<template>
  <div class="app-container">
    <!-- Основной контент -->
    <div class="main-content" :class="{ 'no-right-sidebar': !showWalletSidebar }">
      <div class="header">
        <div class="header-content">
          <div class="header-text">
            <h1 class="title">✌️HB3 - Accelerator DLE</h1>
            <p class="subtitle">Венчурный фонд и поставщик программного обеспечения</p>
          </div>
          <button class="nav-btn header-wallet-btn" @click="toggleWalletSidebar" :class="{ active: showWalletSidebar }">
            <div class="hamburger-line"></div>
            <div class="nav-btn-number">7</div>
            <div class="nav-btn-text">{{ showWalletSidebar ? 'Скрыть панель' : 'Подключиться' }}</div>
          </button>
        </div>
      </div>
      
      <div class="chat-container">
        <div class="chat-messages" ref="messagesContainer">
          <div v-for="message in messages" :key="message.id" 
               :class="['message', 
                       message.sender_type === 'assistant' || message.role === 'assistant' ? 'ai-message' : 
                       message.sender_type === 'system' || message.role === 'system' ? 'system-message' : 'user-message',
                       message.isLocal ? 'is-local' : '',
                       message.hasError ? 'has-error' : '']">
            <div class="message-content" v-html="formatMessage(message.content)"></div>
            <div class="message-meta">
              <div class="message-time">{{ formatTime(message.timestamp || message.created_at) }}</div>
              <div v-if="message.isLocal" class="message-status">
                <span class="sending-indicator">Отправка...</span>
              </div>
              <div v-if="message.hasError" class="message-status">
                <span class="error-indicator">Ошибка отправки</span>
              </div>
            </div>
          </div>
        </div>
        
        <div class="chat-input">
          <textarea 
            v-model="newMessage" 
            placeholder="Введите сообщение..." 
            @keydown.enter.prevent="handleMessage(newMessage)"
            :disabled="isLoading"
            ref="messageInput"
            rows="3"
            autofocus
          ></textarea>
          <div class="chat-buttons">
            <button @click="handleMessage(newMessage)" :disabled="isLoading || !newMessage.trim()">
              {{ isLoading ? 'Отправка...' : 'Отправить' }}
            </button>
            <button @click="clearGuestMessages" class="clear-btn" :disabled="isLoading">
              Очистить
            </button>
          </div>
        </div>
        </div>
          </div>
          
    <!-- Правая панель с информацией о кошельке -->
    <div class="wallet-sidebar" v-if="showWalletSidebar">
      <div class="wallet-header">
        <button v-if="!isAuthenticated" @click="handleWalletAuth" class="wallet-connect-btn-header">
              Подключить кошелек
            </button>
        <button v-if="isAuthenticated" @click="disconnectWallet" class="wallet-disconnect-btn-header">
          Отключить
        </button>
        <button class="close-wallet-sidebar" @click="toggleWalletSidebar">×</button>
      </div>
      
      <!-- Добавляем дополнительные кнопки авторизации -->
      <div v-if="!isAuthenticated" class="auth-buttons">
        <h3>Авторизация через:</h3>
        <div v-if="!showTelegramVerification" class="auth-btn-container">
          <button @click="handleTelegramAuth" class="auth-btn telegram-btn">
            Подключить Telegram
          </button>
        </div>
        <div v-if="showTelegramVerification" class="verification-block">
          <div class="verification-code">
            <span>Код верификации:</span>
            <code @click="copyCode(telegramVerificationCode)">{{ telegramVerificationCode }}</code>
            <span v-if="codeCopied" class="copied-message">Скопировано!</span>
          </div>
          <a :href="telegramBotLink" target="_blank" class="bot-link">Открыть бота Telegram</a>
          <button @click="cancelTelegramAuth" class="cancel-btn">Отмена</button>
        </div>
        
        <!-- Сообщение об ошибке в Telegram -->
        <div v-if="telegramError" class="error-message">
          {{ telegramError }}
          <button class="close-error" @click="telegramError = ''">×</button>
        </div>
        
        <div v-if="!showEmailForm && !showEmailVerificationInput" class="auth-btn-container">
          <button @click="handleEmailAuth" class="auth-btn email-btn">
            Подключить Email
          </button>
        </div>
              
        <!-- Форма для Email верификации -->
        <div v-if="showEmailForm" class="email-form">
          <p>Введите ваш email для получения кода подтверждения:</p>
          <div class="email-form-container">
            <input 
              v-model="emailInput" 
              type="email" 
              placeholder="Ваш email" 
              class="email-input"
              :class="{ 'email-input-error': emailFormatError }"
            />
            <button @click="sendEmailVerification" class="send-email-btn" :disabled="isEmailSending">
              {{ isEmailSending ? 'Отправка...' : 'Отправить код' }}
            </button>
          </div>
          <div class="form-actions">
            <button @click="cancelEmailAuth" class="cancel-btn">Отмена</button>
            <p v-if="emailFormatError" class="email-format-error">Пожалуйста, введите корректный email</p>
          </div>
        </div>
        
        <!-- Форма для ввода кода верификации Email -->
        <div v-if="showEmailVerificationInput" class="email-verification-form">
          <p>На ваш email <strong>{{ emailVerificationEmail }}</strong> отправлен код подтверждения.</p>
          <div class="email-form-container">
            <input 
              v-model="emailVerificationCode" 
              type="text" 
              placeholder="Введите код верификации" 
              maxlength="6"
              class="email-input"
            />
            <button @click="verifyEmailCode" class="send-email-btn" :disabled="isVerifying">
              {{ isVerifying ? 'Проверка...' : 'Подтвердить' }}
            </button>
          </div>
          <button @click="cancelEmailAuth" class="cancel-btn">Отмена</button>
        </div>
      </div>
            
      <!-- Сообщение об ошибке в Email -->
      <div v-if="emailError" class="error-message">
        {{ emailError }}
        <button class="close-error" @click="clearEmailError">×</button>
      </div>
          
      <!-- Блок информации о пользователе -->
      <div v-if="isAuthenticated" class="user-info">
        <h3>Идентификаторы:</h3>
        <div class="user-info-item">
          <span class="user-info-label">Кошелек:</span>
          <span v-if="hasIdentityType('wallet')" class="user-info-value">
            {{ truncateAddress(getIdentityValue('wallet')) }}
          </span>
          <button v-else @click="handleWalletAuth" class="connect-btn">
            Подключить кошелек
          </button>
        </div>
        <div class="user-info-item">
          <span class="user-info-label">Telegram:</span>
          <span v-if="hasIdentityType('telegram')" class="user-info-value">
            {{ getIdentityValue('telegram') }}
          </span>
          <button v-else @click="handleTelegramAuth" class="connect-btn">
            Подключить Telegram
          </button>
        </div>
        <div class="user-info-item">
          <span class="user-info-label">Email:</span>
          <span v-if="hasIdentityType('email')" class="user-info-value">
            {{ getIdentityValue('email') }}
          </span>
          <button v-else @click="handleEmailAuth" class="connect-btn">
            Подключить Email
          </button>
        </div>
      </div>
      
      <!-- Блок форм подключения для аутентифицированных пользователей -->
      <div v-if="isAuthenticated && (showEmailForm || showTelegramVerification || showEmailVerificationInput)" class="connect-forms">
        <!-- Форма для Email верификации -->
        <div v-if="showEmailForm" class="email-form">
          <p>Введите ваш email для получения кода подтверждения:</p>
          <div class="email-form-container">
            <input 
              v-model="emailInput" 
              type="email" 
              placeholder="Ваш email" 
              class="email-input"
              :class="{ 'email-input-error': emailFormatError }"
            />
            <button @click="sendEmailVerification" class="send-email-btn" :disabled="isEmailSending">
              {{ isEmailSending ? 'Отправка...' : 'Отправить код' }}
            </button>
          </div>
          <div class="form-actions">
            <button @click="cancelEmailAuth" class="cancel-btn">Отмена</button>
            <p v-if="emailFormatError" class="email-format-error">Пожалуйста, введите корректный email</p>
          </div>
        </div>

        <!-- Форма для ввода кода верификации Email -->
        <div v-if="showEmailVerificationInput" class="email-verification-form">
          <p>На ваш email <strong>{{ emailVerificationEmail }}</strong> отправлен код подтверждения.</p>
          <div class="email-form-container">
            <input 
              v-model="emailVerificationCode" 
              type="text" 
              placeholder="Введите код верификации" 
              maxlength="6"
              class="email-input"
            />
            <button @click="verifyEmailCode" class="send-email-btn" :disabled="isVerifying">
              {{ isVerifying ? 'Проверка...' : 'Подтвердить' }}
            </button>
          </div>
          <button @click="cancelEmailAuth" class="cancel-btn">Отмена</button>
        </div>

        <!-- Форма для Telegram верификации -->
        <div v-if="showTelegramVerification" class="verification-block">
          <div class="verification-code">
            <span>Код верификации:</span>
            <code @click="copyCode(telegramVerificationCode)">{{ telegramVerificationCode }}</code>
            <span v-if="codeCopied" class="copied-message">Скопировано!</span>
          </div>
          <a :href="telegramBotLink" target="_blank" class="bot-link">Открыть бота Telegram</a>
          <button @click="cancelTelegramAuth" class="cancel-btn">Отмена</button>
        </div>
      </div>
      
      <!-- Блок баланса токенов -->
      <div v-if="isAuthenticated && auth.address?.value" class="token-balances">
        <h3>Баланс токенов:</h3>
        <div class="token-balance">
          <span class="token-name">ETH:</span>
          <span class="token-amount">{{ Number(tokenBalances.eth).toLocaleString() }}</span>
          <span class="token-symbol">{{ TOKEN_CONTRACTS.eth.symbol }}</span>
        </div>
        <div class="token-balance">
          <span class="token-name">BSC:</span>
          <span class="token-amount">{{ Number(tokenBalances.bsc).toLocaleString() }}</span>
          <span class="token-symbol">{{ TOKEN_CONTRACTS.bsc.symbol }}</span>
        </div>
        <div class="token-balance">
          <span class="token-name">ARB:</span>
          <span class="token-amount">{{ Number(tokenBalances.arbitrum).toLocaleString() }}</span>
          <span class="token-symbol">{{ TOKEN_CONTRACTS.arbitrum.symbol }}</span>
        </div>
        <div class="token-balance">
          <span class="token-name">POL:</span>
          <span class="token-amount">{{ Number(tokenBalances.polygon).toLocaleString() }}</span>
          <span class="token-symbol">{{ TOKEN_CONTRACTS.polygon.symbol }}</span>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted, watch, nextTick, onBeforeUnmount } from 'vue';
import { useAuth } from '../composables/useAuth';
import { connectWithWallet } from '../services/wallet';
import axios from 'axios';
import api from '../api/axios';
import DOMPurify from 'dompurify';
import { marked } from 'marked';
import '../assets/styles/home.css';
import { fetchTokenBalances, TOKEN_CONTRACTS } from '../services/tokens';

console.log('HomeView.vue: Version with chat loaded');

// Вспомогательные функции для работы с localStorage
const isLocalStorageAvailable = () => {
  try {
    const test = 'test';
    window.localStorage.setItem(test, test);
    window.localStorage.removeItem(test);
    return true;
  } catch (e) {
    console.error('localStorage is not available:', e);
    return false;
  }
};

const getFromStorage = (key, defaultValue = null) => {
  if (!isLocalStorageAvailable()) return defaultValue;
  try {
    return window.localStorage.getItem(key) || defaultValue;
  } catch (e) {
    console.error(`Error getting ${key} from localStorage:`, e);
    return defaultValue;
  }
};

const setToStorage = (key, value) => {
  if (!isLocalStorageAvailable()) return false;
  try {
    window.localStorage.setItem(key, value);
    return true;
  } catch (e) {
    console.error(`Error setting ${key} in localStorage:`, e);
    return false;
  }
};

const removeFromStorage = (key) => {
  if (!isLocalStorageAvailable()) return false;
  try {
    window.localStorage.removeItem(key);
    return true;
  } catch (e) {
    console.error(`Error removing ${key} from localStorage:`, e);
    return false;
  }
};

// Константы
const auth = useAuth();
const isAuthenticated = computed(() => auth.isAuthenticated.value);
const isConnecting = ref(false);
const messages = ref([]);
const hasUserSentMessage = ref(getFromStorage('hasUserSentMessage') === 'true');
const newMessage = ref('');
const isLoading = ref(false);
const messagesContainer = ref(null);
const userLanguage = ref('ru');

// Состояния для пагинации
const isLoadingMore = ref(false);
const hasMoreMessages = ref(false);
const offset = ref(0);
const limit = ref(30);
const isMessageLoadingInProgress = ref(false); // Добавляем флаг для отслеживания процесса загрузки

// Состояния для верификации
const showTelegramVerification = ref(false);
const telegramVerificationCode = ref('');
const telegramBotLink = ref('');
const telegramAuthCheckInterval = ref(null);
const telegramError = ref('');
const showEmailVerification = ref(false);
const emailVerificationCode = ref('');
const emailError = ref('');
const codeCopied = ref(false);
const showEmailAlternatives = ref(false);

// Состояния для формы ввода кода
const showEmailVerificationInput = ref(false);
const emailVerificationEmail = ref('');

// Состояния для формы ввода email
const showEmailForm = ref(false);
const emailInput = ref('');
const emailFormatError = ref(false);
const isEmailSending = ref(false);

// Состояния для индикации и успешных сообщений
const isVerifying = ref(false);
const successMessage = ref('');
const showSuccessMessage = ref(false);

// Состояния для сайдбара
const showWalletSidebar = ref(false);

// Добавляем состояние для балансов
const tokenBalances = ref({
  eth: '0',
  bsc: '0',
  arbitrum: '0',
  polygon: '0'
});

// Добавляем состояние для отслеживания привязки гостевых сообщений
const isLinkingGuestMessages = ref(false);

// Вычисленное свойство для фильтрации идентификаторов
const filteredIdentities = computed(() => {
  if (!auth.identities || !auth.identities.value) return [];
  
  // Фильтруем идентификаторы, чтобы не показывать те, которые уже отображены в основных полях
  return auth.identities.value.filter(identity => {
    if (identity.provider === 'wallet' && auth.address?.value === identity.provider_id) {
      return false;
    }
    if (identity.provider === 'telegram' && auth.telegramId?.value === identity.provider_id) {
      return false;
    }
    if (identity.provider === 'email' && auth.email?.value === identity.provider_id) {
      return false;
    }
    return true;
  });
});

// Функция для форматирования названий провайдеров
function formatIdentityProvider(provider) {
  const providers = {
    'wallet': 'Кошелек',
    'email': 'Email',
    'telegram': 'Telegram',
    'guest': 'Гость'
  };
  return providers[provider] || provider;
}

// Функция для переключения отображения правой панели
const toggleWalletSidebar = () => {
  showWalletSidebar.value = !showWalletSidebar.value;
  // Сохраняем в localStorage предпочтение пользователя
  setToStorage('showWalletSidebar', showWalletSidebar.value.toString());
};

// Функция для копирования кода
const copyCode = (code) => {
  navigator.clipboard.writeText(code).then(() => {
    codeCopied.value = true;
    setTimeout(() => {
      codeCopied.value = false;
    }, 2000);
  });
};

// Функция для очистки ошибки
const clearEmailError = () => {
  emailError.value = '';
};

// Обработчик для Email аутентификации
const handleEmailAuth = async () => {
  try {
    console.log('Starting email authentication flow');
    
    // Показываем форму для ввода email
    showEmailForm.value = true;
    
    // Сбрасываем другие состояния форм
    showEmailVerification.value = false;
    showEmailVerificationInput.value = false;
    
    // Очищаем поля и ошибки
    emailInput.value = '';
    emailFormatError.value = false;
    emailError.value = '';
    
    console.log('Email form displayed, form states:', {
      showEmailForm: showEmailForm.value,
      showEmailVerification: showEmailVerification.value,
      showEmailVerificationInput: showEmailVerificationInput.value
    });
  } catch (error) {
    console.error('Error initializing email auth:', error);
  }
};

// Функция для отправки запроса на верификацию email
const sendEmailVerification = async () => {
  try {
    emailFormatError.value = false;
    emailError.value = '';
    
    // Проверяем формат email
    if (!emailInput.value || !emailInput.value.match(/^[^\s@]+@[^\s@]+\.[^\s@]+$/)) {
      emailFormatError.value = true;
      return;
    }
    
    isEmailSending.value = true;
    
    // Отправляем запрос на сервер для инициализации email аутентификации
    const response = await axios.post('/api/auth/email/init', { email: emailInput.value });
    
    console.log('Email init response:', response.data);
    
    if (response.data.success) {
      // Скрываем форму ввода email
      showEmailForm.value = false;
      // Показываем форму для ввода кода
      showEmailVerificationInput.value = true;
      // Скрываем старую форму кода верификации
      showEmailVerification.value = false;
      // Сохраняем email
      emailVerificationEmail.value = emailInput.value;
      // Очищаем поле для ввода кода
      emailVerificationCode.value = '';
      
      console.log('Showing verification code input form for email:', emailVerificationEmail.value);
    } else {
      emailError.value = response.data.error || 'Ошибка инициализации аутентификации по email';
      // Возвращаем форму ввода email в исходное состояние
      showEmailForm.value = true;
      showEmailVerificationInput.value = false;
    }
  } catch (error) {
    console.error('Error in email init request:', error);
    if (error.response && error.response.data && error.response.data.error) {
      emailError.value = error.response.data.error;
    } else {
      emailError.value = 'Ошибка при запросе кода подтверждения';
    }
    // Возвращаем форму ввода email в исходное состояние
    showEmailForm.value = true;
    showEmailVerificationInput.value = false;
  } finally {
    isEmailSending.value = false;
  }
};

// Функция для обработки загрузки сообщений после аутентификации
const handlePostAuthMessageLoading = async (authType) => {
  try {
    isMessageLoadingInProgress.value = true;
    
    // Загружаем историю сообщений напрямую через API
    const response = await axios.get('/api/chat/history');
    if (response.data.success) {
      messages.value = response.data.messages || [];
      console.log(`Загружено ${messages.value.length} сообщений после аутентификации`);
      
      // Очищаем локальное хранилище гостевых сообщений
      localStorage.removeItem('guestMessages');
      localStorage.removeItem('guestId');
      
      // Прокручиваем к последнему сообщению
      await nextTick();
      scrollToBottom();
    }
  } catch (error) {
    console.error(`Ошибка при обработке сообщений после аутентификации через ${authType}:`, error);
  } finally {
    isMessageLoadingInProgress.value = false;
  }
};

// Обработчик для Telegram аутентификации
const handleTelegramAuth = async () => {
  try {
    showTelegramVerification.value = true;
    telegramError.value = '';
    
    // Инициализируем процесс аутентификации через Telegram
    const response = await axios.post('/api/auth/telegram/init');
    
    if (response.data.success) {
      // Используем правильное имя свойства из ответа API
      telegramVerificationCode.value = response.data.verificationCode;
      telegramBotLink.value = response.data.botLink;
      
      // Создаем интервал для проверки состояния авторизации
      telegramAuthCheckInterval.value = setInterval(async () => {
        try {
          const checkResponse = await auth.checkAuth();
          if (checkResponse.authenticated && checkResponse.authType === 'telegram') {
            console.log('Telegram аутентификация успешна');
            clearTelegramInterval();
            showTelegramVerification.value = false;
            telegramVerificationCode.value = '';
            
            // Обрабатываем загрузку сообщений после успешной аутентификации
            await handlePostAuthMessageLoading('telegram');
          }
        } catch (error) {
          console.error('Ошибка при проверке аутентификации:', error);
        }
      }, 2000); // Проверяем каждые 2 секунды
    } else {
      telegramError.value = response.data.error || 'Ошибка при инициализации авторизации Telegram';
      showTelegramVerification.value = false;
    }
  } catch (error) {
    console.error('Ошибка инициализации Telegram аутентификации:', error);
    telegramError.value = 'Произошла ошибка при инициализации аутентификации через Telegram';
    showTelegramVerification.value = false;
  }
};

// Функция для обновления балансов
const updateBalances = async () => {
  if (auth.isAuthenticated.value && auth.address?.value) {
    try {
      console.log('Запрос балансов для адреса:', auth.address.value);
      const balances = await fetchTokenBalances();
      console.log('Полученные балансы:', balances);
      
      // Обновляем каждый баланс отдельно для реактивности
      tokenBalances.value = {
        eth: balances.eth || '0',
        bsc: balances.bsc || '0',
        arbitrum: balances.arbitrum || '0',
        polygon: balances.polygon || '0'
      };
      
      console.log('Обновленные балансы в интерфейсе:', tokenBalances.value);
    } catch (error) {
      console.error('Ошибка при обновлении балансов:', error);
    }
  } else {
    console.log('Пользователь не аутентифицирован или адрес не доступен');
  }
};

// Добавляем наблюдатель за изменением адреса
watch(() => auth.address?.value, (newAddress) => {
  if (newAddress) {
    console.log('Адрес кошелька изменился, обновляем балансы');
    updateBalances();
  }
});

// Функция для периодического обновления балансов
let balanceUpdateInterval = null;

const startBalanceUpdates = () => {
  // Обновляем балансы сразу
  updateBalances();
  
  // Увеличиваем интервал обновления до 5 минут
  balanceUpdateInterval = setInterval(updateBalances, 300000);
};

const stopBalanceUpdates = () => {
  if (balanceUpdateInterval) {
    clearInterval(balanceUpdateInterval);
    balanceUpdateInterval = null;
  }
};

// Функция для подключения кошелька - обновленная версия
const handleWalletAuth = async () => {
  if (isConnecting.value || isAuthenticated.value) return;
  
  isConnecting.value = true;
  try {
    const result = await connectWithWallet();
    console.log('Результат подключения кошелька:', result);
    
    if (result.success) {
      // Обновляем состояние авторизации
      const authResponse = await auth.checkAuth();
      
      if (authResponse.authenticated && authResponse.authType === 'wallet') {
        console.log('Кошелёк успешно подключен и аутентифицирован');
        
        // Обрабатываем загрузку сообщений после успешной аутентификации
        await handlePostAuthMessageLoading('wallet');
        
        // Запускаем обновление балансов
        startBalanceUpdates();
      }
      
      // Добавляем небольшую задержку перед сбросом состояния isConnecting
      setTimeout(() => {
        isConnecting.value = false;
      }, 500);
      return;
    } else {
      console.error('Не удалось подключить кошелёк:', result.error);
    }
  } catch (error) {
    console.error('Ошибка при подключении кошелька:', error);
  }
  
  isConnecting.value = false;
};

// Функция для проверки кода верификации email - обновленная версия
const verifyEmailCode = async () => {
  try {
    // Очищаем сообщение об ошибке
    emailError.value = '';
    
    if (!emailVerificationCode.value) {
      emailError.value = 'Пожалуйста, введите код верификации';
      return;
    }
    
    // Показываем индикатор процесса верификации
    isVerifying.value = true;
    
    const response = await axios.post('/api/auth/email/verify-code', {
      email: emailVerificationEmail.value,
      code: emailVerificationCode.value
    });
    
    if (response.data.success) {
      // Сбрасываем все состояния форм email
      showEmailVerificationInput.value = false;
      showEmailForm.value = false;
      showEmailVerification.value = false;
      
      // Показываем сообщение об успешной верификации
      successMessage.value = `Email ${emailVerificationEmail.value} успешно подтвержден!`;
      showSuccessMessage.value = true;
      
      // Скрываем сообщение через 3 секунды
      setTimeout(() => {
        showSuccessMessage.value = false;
      }, 3000);
      
      // Обновляем состояние аутентификации
      const authResponse = await auth.checkAuth();
      
      if (authResponse.authenticated && authResponse.authType === 'email') {
        console.log('Email успешно подтвержден и аутентифицирован');
        
        // Обрабатываем загрузку сообщений после успешной аутентификации
        await handlePostAuthMessageLoading('email');
      }
    } else {
      emailError.value = response.data.message || 'Неверный код верификации';
    }
  } catch (error) {
    if (error.response && error.response.status === 400) {
      // Обрабатываем ошибку неверного кода
      emailError.value = error.response.data.error || 'Неверный код верификации';
    } else {
      emailError.value = 'Ошибка при проверке кода';
      console.error('Error verifying email code:', error);
    }
  } finally {
    isVerifying.value = false;
  }
};

// Улучшенная функция для отслеживания изменений аутентификации
const watchAuthChanges = () => {
  // Отслеживаем изменения в состоянии аутентификации
  watch(() => auth.isAuthenticated.value, async (newValue, oldValue) => {
    const authChanged = {
      from: oldValue,
      to: newValue,
      userId: auth.userId.value,
      authType: auth.authType.value
    };
    
    console.log('Состояние аутентификации изменилось:', authChanged);
    
    // Обновляем отображение аутентификации
    updateAuthDisplay({
      isAuthenticated: auth.isAuthenticated.value,
      authType: auth.authType.value,
      address: auth.address.value,
      email: auth.email.value,
      telegramId: auth.telegramId.value,
      telegramUsername: auth.telegramUsername
    });
    
    if (newValue && !oldValue) {
      // Пользователь только что аутентифицировался
      console.log(`Пользователь аутентифицирован через ${auth.authType.value}, загружаем историю и проверяем новые сообщения`);
      
      // Обрабатываем загрузку сообщений после аутентификации
      await handlePostAuthMessageLoading(auth.authType.value);
    } else if (!newValue && oldValue) {
      // Пользователь вышел из системы
      console.log('Пользователь вышел, сбрасываем сообщения');
      messages.value = messages.value.filter(msg => msg.isGuest);
      offset.value = 0;
      hasMoreMessages.value = true;
    }
  }, { immediate: true });
};

// Функция для форматирования времени
const formatTime = (timestamp) => {
  if (!timestamp) return '';
  
  try {
    const date = new Date(timestamp);
    
    // Проверяем, является ли дата валидной
    if (isNaN(date.getTime())) {
      console.warn('Invalid timestamp:', timestamp);
      return '';
    }
    
    // Форматируем дату с указанием дня, месяца, года и времени
    return date.toLocaleString([], { 
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  } catch (error) {
    console.error('Error formatting time:', error, timestamp);
    return '';
  }
};

// Форматирование сообщения с поддержкой markdown
const formatMessage = (text) => {
  if (!text) return '';
  const rawHtml = marked.parse(text);
  return DOMPurify.sanitize(rawHtml);
};

// Функция для сокращения адреса кошелька (первые 6 и последние 4 символа)
function truncateAddress(address) {
  if (!address) return '';
  return `${address.substring(0, 6)}...${address.substring(address.length - 4)}`;
}

// Вычисляемое свойство для гостевого ID
const guestIdValue = computed(() => {
  return getFromStorage('guestId', '');
});

// Функции для отладки гостевых идентификаторов
const refreshGuestId = () => {
  const newGuestId = generateUniqueId();
  setToStorage('guestId', newGuestId);
  console.log('Guest ID refreshed:', newGuestId);
};

const clearGuestMessages = () => {
  removeFromStorage('guestMessages');
  console.log('Guest messages cleared');
  messages.value = messages.value.filter(m => !m.isGuest);
};

// Метод для загрузки истории чата
const loadChatHistory = async () => {
  isLoading.value = true;
  
  try {
    // Если пользователь аутентифицирован и есть гостевые сообщения, 
    // но привязка уже выполняется - ждем её завершения
    if (auth.isAuthenticated.value && isLinkingGuestMessages.value) {
      await new Promise(resolve => {
        const checkInterval = setInterval(() => {
          if (!isLinkingGuestMessages.value) {
            clearInterval(checkInterval);
            resolve();
          }
        }, 100);
      });
    }

    // Получаем общее количество сообщений
    const countResponse = await axios.get('/api/chat/history?count_only=true');
    
    if (countResponse.data.success) {
      const messageCount = countResponse.data.count;
      console.log(`История содержит ${messageCount} сообщений`);
      
      const effectiveOffset = Math.max(0, messageCount - limit.value);
      const response = await axios.get(`/api/chat/history?offset=${effectiveOffset}&limit=${limit.value}`);
      
      if (response && response.data.success) {
        messages.value = response.data.messages;
        console.log(`Загружено ${messages.value.length} сообщений из истории`);
        
        window.dispatchEvent(new CustomEvent('messages-updated', { 
          detail: { count: messages.value.length } 
        }));
        
        await nextTick();
        scrollToBottom();
      }
    }
  } catch (error) {
    console.error('Ошибка загрузки истории чата:', error);
  } finally {
    isLoading.value = false;
  }
};

// Метод для очистки интервала проверки авторизации
const clearTelegramInterval = () => {
  if (telegramAuthCheckInterval.value) {
    clearInterval(telegramAuthCheckInterval.value);
    telegramAuthCheckInterval.value = null;
    console.log('Интервал проверки Telegram авторизации очищен');
  }
};

// Метод для обновления отображения аутентификации
const updateAuthDisplay = (state) => {
  console.log('Updating auth display:', state);
  
  // Обновляем отображение в зависимости от типа аутентификации
  if (state.isAuthenticated) {
    const authTypeLabels = {
      'wallet': 'Кошелек',
      'email': 'Email',
      'telegram': 'Telegram'
    };
    
    let authLabel = authTypeLabels[state.authType] || 'Аккаунт';
    let authValue = '';
    
    if (state.authType === 'wallet' && state.address) {
      authValue = truncateAddress(state.address);
      // Добавляем класс для отображения подключенного состояния
      document.body.classList.add('wallet-connected');
    } else if (state.authType === 'email' && state.email) {
      authValue = state.email;
    } else if (state.authType === 'telegram' && state.telegramUsername) {
      authValue = state.telegramUsername;
    } else if (state.authType === 'telegram' && state.telegramId) {
      authValue = `ID: ${state.telegramId}`;
    }
    
    // Обновляем текст в интерфейсе
    const authDisplayEl = document.getElementById('auth-display');
    if (authDisplayEl) {
      authDisplayEl.innerHTML = `${authLabel}: <strong>${authValue}</strong>`;
      authDisplayEl.style.display = 'inline-block';
    }
    
    // Скрываем кнопки авторизации
    const authButtonsEl = document.getElementById('auth-buttons');
    if (authButtonsEl) {
      authButtonsEl.style.display = 'none';
    }
    
    // Показываем кнопку выхода
    const logoutButtonEl = document.getElementById('logout-button');
    if (logoutButtonEl) {
      logoutButtonEl.style.display = 'inline-block';
    }
  } else {
    // Сбрасываем классы при отсутствии аутентификации
    document.body.classList.remove('wallet-connected');
    
    // Скрываем отображение аутентификации
    const authDisplayEl = document.getElementById('auth-display');
    if (authDisplayEl) {
      authDisplayEl.style.display = 'none';
    }
    
    // Показываем кнопки авторизации
    const authButtonsEl = document.getElementById('auth-buttons');
    if (authButtonsEl) {
      authButtonsEl.style.display = 'inline-block';
    }
    
    // Скрываем кнопку выхода
    const logoutButtonEl = document.getElementById('logout-button');
    if (logoutButtonEl) {
      logoutButtonEl.style.display = 'none';
    }
  }
}

// Генерация уникального ID с помощью времени и случайного числа
function generateUniqueId() {
  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}

// Функция для отправки сообщения
const handleMessage = async (text) => {
  if (!text.trim()) return;
  
  try {
    // Добавляем сообщение в список
    const userMessageContent = text.trim();
    const tempId = generateUniqueId();
    
    const userMessage = {
      id: tempId,
      content: userMessageContent,
      sender_type: 'user',
      role: 'user',
      isLocal: true,
      isGuest: !auth.isAuthenticated.value,
      timestamp: new Date().toISOString()
    };
    
    messages.value.push(userMessage);
    
    // Очищаем поле ввода
    newMessage.value = '';
    
    // Прокручиваем к последнему сообщению
    scrollToBottom();
    
    // Устанавливаем состояние загрузки
    isLoading.value = true;
    
    try {
      if (auth.isAuthenticated.value) {
        // Отправляем сообщение как авторизованный пользователь
        const response = await axios.post('/api/chat/message', {
          message: userMessageContent,
          language: userLanguage.value
        });
        
        if (response.data.success) {
          // Обновляем ID сообщения пользователя
          const userMsgIndex = messages.value.findIndex(m => m.id === tempId);
          if (userMsgIndex !== -1) {
            messages.value[userMsgIndex].id = response.data.userMessage.id;
            messages.value[userMsgIndex].isLocal = false;
          }
          
          // Добавляем ответ ИИ
          messages.value.push({
            id: response.data.aiMessage.id,
            content: response.data.aiMessage.content,
            sender_type: 'assistant',
            role: 'assistant',
            timestamp: response.data.aiMessage.created_at
          });
          
          // Прокручиваем к последнему сообщению
          scrollToBottom();
        }
      } else {
        // Отправляем сообщение как гость
        console.log('Sending guest message:', userMessageContent);
        
        // Получаем или создаем идентификатор гостя
        let guestId = getFromStorage('guestId');
        if (!guestId) {
          guestId = generateUniqueId();
          setToStorage('guestId', guestId);
        }
        
        const response = await axios.post('/api/chat/guest-message', {
          content: userMessageContent,
          guestId,
          language: userLanguage.value
        });
        
        if (response.data.success) {
          console.log('Guest message sent:', response.data);
          
          // Обновляем ID сообщения пользователя
          const userMsgIndex = messages.value.findIndex(m => m.id === tempId);
          if (userMsgIndex !== -1) {
            messages.value[userMsgIndex].id = response.data.messageId;
            messages.value[userMsgIndex].isLocal = false;
          }
          
          // Сохраняем сообщение в localStorage
          try {
            const storedMessages = JSON.parse(getFromStorage('guestMessages', '[]'));
            storedMessages.push({
              id: response.data.messageId,
              content: userMessageContent,
              sender_type: 'user',
              role: 'user',
              isGuest: true,
              timestamp: new Date().toISOString()
            });
            setToStorage('guestMessages', JSON.stringify(storedMessages));
            setToStorage('hasUserSentMessage', 'true');
            hasUserSentMessage.value = true;
          } catch (storageError) {
            console.error('Error saving message to localStorage:', storageError);
          }
          
          // Показываем правую панель, если она скрыта
          if (!showWalletSidebar.value) {
            showWalletSidebar.value = true;
            try {
              setToStorage('showWalletSidebar', 'true');
            } catch (storageError) {
              console.error('Error saving sidebar state to localStorage:', storageError);
            }
          }
        }
      }
    } catch (error) {
      console.error('Error sending message:', error);
      // Помечаем сообщение как ошибочное
      const userMsgIndex = messages.value.findIndex(m => m.id === tempId);
      if (userMsgIndex !== -1) {
        messages.value[userMsgIndex].hasError = true;
      }
      
      // Добавляем сообщение об ошибке в чат
      messages.value.push({
        id: `error-${Date.now()}`,
        content: 'Произошла ошибка при отправке сообщения. Пожалуйста, попробуйте еще раз.',
        sender_type: 'system',
        role: 'system',
        timestamp: new Date().toISOString()
      });
      scrollToBottom();
    } finally {
      isLoading.value = false;
    }
  } catch (error) {
    console.error('Unexpected error in handleMessage:', error);
    isLoading.value = false;
  }
};

// Функция для прокрутки к последнему сообщению
const scrollToBottom = () => {
  if (messagesContainer.value) {
    setTimeout(() => {
      messagesContainer.value.scrollTop = messagesContainer.value.scrollHeight;
    }, 100);
  }
};

// Обработка прокрутки
const handleScroll = async () => {
  const element = messagesContainer.value;
  if (
    !isLoadingMore.value &&
    hasMoreMessages.value &&
    element.scrollTop === 0
  ) {
    await loadMoreMessages();
  }
};

// Функция для отмены аутентификации через Telegram
const cancelTelegramAuth = () => {
  // Очищаем интервал проверки
  clearTelegramInterval();
  
  // Сбрасываем состояния интерфейса
  showTelegramVerification.value = false;
  telegramVerificationCode.value = '';
  telegramError.value = '';
  
  console.log('Аутентификация Telegram отменена пользователем');
};

// Вычисленное свойство для определения, нужно ли загружать историю
const shouldLoadHistory = computed(() => {
  // Загружаем историю только если пользователь авторизован или есть гостевой ID
  return isAuthenticated.value || 
    (getFromStorage('guestId') && getFromStorage('guestId').length > 0);
});

// Метод для периодической проверки новых сообщений
const setupMessagePolling = (initialCount) => {
  console.log(`Настраиваю отслеживание сообщений с начальным количеством: ${initialCount}`);
  let messageCheckInterval;
  
  const clearMessagePolling = () => {
    if (messageCheckInterval) {
      clearInterval(messageCheckInterval);
      messageCheckInterval = null;
      console.log('Отслеживание сообщений остановлено');
    }
  };
  
  // Очищаем предыдущий интервал, если он существует
  clearMessagePolling();
  
  // Создаем новый интервал для проверки сообщений
  messageCheckInterval = setInterval(async () => {
    try {
      // Проверяем, есть ли новые сообщения
      const newCountResponse = await axios.get('/api/chat/history?count_only=true');
      
      if (newCountResponse.data.success) {
        const newCount = newCountResponse.data.count;
        console.log(`Проверка новых сообщений: ${newCount} / ${initialCount}`);
        
        if (newCount > initialCount) {
          console.log(`Обнаружены новые сообщения: ${newCount} > ${initialCount}`);
          
          // Рассчитываем смещение для получения последних сообщений
          const effectiveOffset = Math.max(0, newCount - limit.value);
          
          // Загружаем обновленную историю
          const newResponse = await axios.get(`/api/chat/history?offset=${effectiveOffset}&limit=${limit.value}`);
          
          if (newResponse && newResponse.data.success) {
            messages.value = newResponse.data.messages;
            console.log('Сообщения обновлены с новыми ответами');
            
            // Прокручиваем к последнему сообщению
            await nextTick();
            scrollToBottom();
            
            // Останавливаем интервал после получения ответа
            clearMessagePolling();
          }
        }
      }
    } catch (error) {
      console.error('Ошибка при проверке новых сообщений:', error);
      clearMessagePolling();
    }
  }, 2000); // Проверяем каждые 2 секунды
  
  // Останавливаем интервал после 30 секунд в любом случае
  setTimeout(() => {
    clearMessagePolling();
  }, 30000);
  
  return clearMessagePolling;
};

// Отслеживаем изменения в сообщениях
watch(() => messages.value.length, (newLength, oldLength) => {
  if (newLength > 0) {
    // Сортируем сообщения по дате/времени
    messages.value.sort((a, b) => {
      const dateA = new Date(a.timestamp || a.created_at);
      const dateB = new Date(b.timestamp || b.created_at);
      return dateA - dateB;
    });
    
    // Прокручиваем к последнему сообщению
    nextTick(() => {
      scrollToBottom();
    });
  }
});

// Функция для отключения кошелька/выхода
const disconnectWallet = async () => {
  try {
    console.log('Выполняется выход из системы...');
    
    // Останавливаем обновление балансов
    stopBalanceUpdates();
    
    // Отправляем запрос на выход
    await axios.post('/api/auth/logout');
    
    // Обновляем состояние аутентификации локально
    auth.isAuthenticated.value = false;
    auth.address.value = null;
    auth.authType.value = null;
    auth.telegramId.value = null;
    auth.email.value = null;
    
    // Обновляем отображение UI
    document.body.classList.remove('wallet-connected');
    
    // Очищаем все сообщения и состояния
    messages.value = [];
    offset.value = 0;
    hasMoreMessages.value = true;
    
    // Очищаем localStorage от всех сообщений
    localStorage.removeItem('guestMessages');
    localStorage.removeItem('hasUserSentMessage');
    
    console.log('Выход из системы выполнен успешно');
  } catch (error) {
    console.error('Ошибка при выходе из системы:', error);
  }
};

// Функция для загрузки сообщений
const loadMoreMessages = async (silent = false) => {
  if (isLoadingMore.value) return;
  
  try {
    isLoadingMore.value = true;
    if (!silent) isLoading.value = true;
    
    console.log('Fetching chat history...');
    
    // Проверяем сессию перед загрузкой истории
    try {
      const sessionCheck = await axios.get('/api/auth/check');
      console.log('Session check:', sessionCheck.data);
      
      // Проверяем, что пользователь все еще аутентифицирован
      if (!sessionCheck.data.authenticated && !shouldLoadHistory.value) {
        console.warn('User is not authenticated, skipping message history load');
        isLoadingMore.value = false;
        isLoading.value = false;
        return;
      }
    } catch (error) {
      console.warn('Session check failed, but continuing anyway:', error);
    }
    
    // Сначала запрашиваем общее количество сообщений
    const countResponse = await axios.get('/api/chat/history', {
      params: {
        count_only: true
      }
    });
    
    if (!countResponse.data.success) {
      throw new Error('Failed to get message count');
    }
    
    const totalMessages = countResponse.data.total || 0;
    console.log(`Total messages in history: ${totalMessages}`);
    
    // Рассчитываем offset так, чтобы получить последние сообщения
    // при первой загрузке (когда offset = 0)
    let effectiveOffset = offset.value;
    if (offset.value === 0 && totalMessages > limit.value) {
      // Загружаем последние сообщения вместо первых
      effectiveOffset = Math.max(0, totalMessages - limit.value);
    }
    
    // Получаем историю сообщений с параметрами пагинации
    const response = await axios.get('/api/chat/history', {
      params: {
        offset: effectiveOffset,
        limit: limit.value
      }
    });
    
    console.log('Chat history response:', response.data);
    
    if (response.data.success) {
      // Если это первая загрузка, заменяем сообщения
      // Иначе, добавляем полученные сообщения к существующим
      if (offset.value === 0) {
        messages.value = response.data.messages || [];
      } else if (response.data.messages && response.data.messages.length) {
        messages.value = [...messages.value, ...response.data.messages];
      }
      
      // Обновляем offset для следующей загрузки
      offset.value = effectiveOffset + (response.data.messages?.length || 0);
      
      // Проверяем, есть ли еще сообщения для загрузки
      hasMoreMessages.value = offset.value < totalMessages;
    }
    
    // После загрузки первой порции сообщений считаем, что пользователь уже отправлял сообщения
    if (messages.value.length > 0) {
      hasUserSentMessage.value = true;
      window.localStorage.setItem('hasUserSentMessage', 'true');
    }
    
    // Прокручиваем контейнер с сообщениями вниз
    await nextTick();
    scrollToBottom();
  } catch (error) {
    console.error('Error loading chat history:', error);
  } finally {
    isLoadingMore.value = false;
    isLoading.value = false;
  }
};

// Функция для отмены Email аутентификации
const cancelEmailAuth = () => {
  showEmailForm.value = false;
  showEmailVerificationInput.value = false;
  showEmailVerification.value = false;
  emailInput.value = '';
  emailVerificationCode.value = '';
  emailError.value = '';
  emailFormatError.value = false;
};

// Методы для работы с идентификаторами
const hasIdentityType = (type) => {
  if (!auth.identities?.value) return false;
  return auth.identities.value.some(identity => identity.provider === type);
};

const getIdentityValue = (type) => {
  if (!auth.identities?.value) return null;
  const identity = auth.identities.value.find(identity => identity.provider === type);
  return identity ? identity.provider_id : null;
};

// Функции жизненного цикла
onMounted(async () => {
  console.log('HomeView.vue: компонент загружен');
  
  // Проверяем состояние аутентификации
  console.log('Состояние аутентификации при загрузке:', {
    isAuthenticated: auth.isAuthenticated.value,
    authType: auth.authType.value,
    telegramId: auth.telegramId.value
  });

  // Загружаем сохраненное состояние боковой панели
  const savedSidebarState = getFromStorage('showWalletSidebar');
  if (savedSidebarState !== null) {
    showWalletSidebar.value = savedSidebarState === 'true';
  } else {
    // По умолчанию показываем панель, если не указано иное
    showWalletSidebar.value = true;
    setToStorage('showWalletSidebar', 'true');
  }
  
  // Запускаем отслеживание изменений
  watchAuthChanges();
  
  // Установка обработчика скролла
  if (messagesContainer.value) {
    messagesContainer.value.addEventListener('scroll', handleScroll);
  }
  
  // Загружаем историю сообщений
  if (shouldLoadHistory.value) {
    // Получаем сессию пользователя
    const { data: sessionData } = await api.get('/api/auth/check');
    console.log('Проверка сессии:', sessionData);
    
    if (!isAuthenticated.value && !sessionData.authenticated) {
      // Пробуем загрузить локальные сообщения
      try {
        // Проверяем наличие сообщений в localStorage
        const storedMessages = getFromStorage('guestMessages');
        if (storedMessages) {
          const parsedMessages = JSON.parse(storedMessages);
          if (parsedMessages.length > 0) {
            console.log(`Найдено ${parsedMessages.length} сохраненных гостевых сообщений`);
            
            // Если пользователь не аутентифицирован, добавляем гостевые сообщения
            if (!isAuthenticated.value) {
              messages.value = [...messages.value, ...parsedMessages];
              hasUserSentMessage.value = true;
              setToStorage('hasUserSentMessage', 'true');
            } else {
              // Если пользователь аутентифицирован, удаляем гостевые сообщения из localStorage
              console.log('Пользователь аутентифицирован, удаляем гостевые сообщения из localStorage');
              removeFromStorage('guestMessages');
            }
          }
        }
      } catch (e) {
        console.error('Ошибка загрузки сообщений из localStorage:', e);
      }
    }
    
    if (isAuthenticated.value) {
      await loadMoreMessages();
    }
  }
  
  // Добавляем слушатель события для загрузки истории чата
  window.addEventListener('load-chat-history', loadChatHistory);
  
  // Установка статуса отправленных сообщений
  if (messages.value.length > 0) {
    hasUserSentMessage.value = true;
    setToStorage('hasUserSentMessage', 'true');
  }
  
  // Проверяем аутентификацию только если нет данных в localStorage
  const cachedAuth = localStorage.getItem('authData');
  if (!cachedAuth) {
    const { data: sessionData } = await api.get('/api/auth/check');
    console.log('Проверка сессии:', sessionData);
    
    if (sessionData.authenticated && sessionData.authType === 'wallet') {
      // Запускаем обновление балансов
      startBalanceUpdates();
    }
  } else {
    // Используем кэшированные данные
    const authData = JSON.parse(cachedAuth);
    if (authData.authenticated && authData.authType === 'wallet') {
      startBalanceUpdates();
    }
  }
  
  // Прокручиваем к последнему сообщению
  scrollToBottom();
});

// Очистка слушателей событий при размонтировании компонента
onBeforeUnmount(() => {
  if (messagesContainer.value) {
    messagesContainer.value.removeEventListener('scroll', handleScroll);
  }
  window.removeEventListener('load-chat-history', loadChatHistory);
  
  // Останавливаем обновление балансов
  stopBalanceUpdates();
});
</script>
